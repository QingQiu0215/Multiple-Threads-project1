# Multiple-Threads-project1

Valid stack state:
[a][b][c][d][e][$]...
↑ ↑
+--bottom +--top
Invalid stack state:
[b][a][c][$][d][$]...
↑ ↑
+--bottom +--top
Multiple Producer and Consumer threads operate on the shared stack, and perform Push
and Pop operations respectively. Details of these operations are elaborated in the
following tasks. In addition, there is another thread of execution called CharStackProber,
which periodically prints out the contents of the stack; this is for checking the validity
of the stack. As a difference from assignment 1, you will be using semaphore(s) for
mutually exclusive access to the shared stack.
The source code for this assignment is supplied separately. You will need to separate the
source code into multiple files. You will also need to fill in the missing code. You have to
complete the following tasks as part of this assignment:
Organize: (i) Organize the given code into multiple source files. (ii) Understand the code.
(iii) Ensure that you are working on a native thread environment.
Task 1: Refer to the Semaphore class supplied and answer the following: according to the
classical definition of a semaphore, it can be initialized only to a non-negative value. If the
value of a semaphore becomes negative (via Wait() operation), then its absolute value
indicates the number of processes/threads on its wait queue. Does the given semaphore class
implementation satisfy these requirements? If not, modify the semaphore class
implementation accordingly. Submit the modified code.
Task 2: Refer to the StackManager class supplied. Inside the main() routine, it starts two
Producer threads, two Consumer threads, and a CharStackProber thread which periodically
prints out the stack state. Note that all five threads access the same stack, and hence mutual
exclusion is mandatory to maintain validity of the stack at all times. You will use the modified
Semaphore class (Task 1) to implement the mutual exclusion of the shared data. Following
are the specific details of the task:
(i) Each Producer thread goes in a loop three times, and each time in the loop it first checks
for the character on the top of the stack (without removing it), and then pushes the next
higher character into the stack. For instance, if the current top of the stack is ‘d’ then it
pushes ‘e’. Fill in the missing code for the Producer class. Note that your code must be
able to handle the necessary exceptions (e.g., stack full).
(ii) Each Consumer thread goes in a loop three times, and each time in the loop it pops out
the item from the top of the stack. Fill in the missing code for the Consumer class, taking
proper care for exceptions.
(iii)The CharStackProber thread goes in a loop six times and each time in the loop, it prints
out the contents of the stack in the format shown in the following example. For example:
if the current contents of the stack are ‘a’, ‘b’, ‘c’, then it prints out in the format “Stack
S = ([a],[b],[c],[$],[$],[$],[$],[$],[$],[$])”. Fill in the missing code. Note that your output
must conform to this format so that Task 3 in the following can be addressed.
Submit the complete program.
Task 3: Complete the following:
(i) Run the completed program three times, and dump the output of run i to a file named:
Output_i.txt (i = 1..3).
(ii) We are also interested in specifically checking the output generated by CharStackProber.
To achieve this, you run the program three more times, however using the following
command: java StackManager | grep ‘Stack S’ (Note: this command is to be issued from
the shell command prompt on a Linux environment; for equivalent commands on your
Java development toolkit, consult the manual and/or talk to your TAs). Dump the output
of each run i to the file named: Grep_i.txt (i = 1..3).
Submit the outputs of the above.
Task 4: You will bring in some extra synchronization to the completed code as follows: the
two Producer threads, which run concurrently, must first complete pushing characters into
the stack, only after which the two Consumer threads can concurrently access the stack. There
is no restriction on the CharStackProber thread and so its code remains unchanged. You must
not alter any code of the main() routine of the StackManager class. The required
synchronization must be achieved through the use of Semaphores (the modified Semaphore
class in Task 1), and mutual exclusion of the stack must be preserved at all times. Use
minimum possible synchronization to achieve the result. Submit the modified program.

